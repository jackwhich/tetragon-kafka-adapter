input {  
  # Tetragon 事件 - 进程执行
  kafka {
    bootstrap_servers => "172.30.32.85:9092,172.30.32.85:9093,172.30.32.85:9094"
    topics => ["tetragon.process.exec"]
    group_id => "logstash-k8s-tetragon-process-exec"
    auto_offset_reset => "latest"
    codec => json
    decorate_events => true
    # consumer_threads => 8
  }
  
  # Tetragon 事件 - 进程退出
  kafka {
    bootstrap_servers => "172.30.32.85:9092,172.30.32.85:9093,172.30.32.85:9094"
    topics => ["tetragon.process.exit"]
    group_id => "logstash-k8s-tetragon-process-exit"
    auto_offset_reset => "latest"
    codec => json
    decorate_events => true
    # consumer_threads => 8
  }
  
  # Tetragon 事件 - 安全 LSM
  kafka {
    bootstrap_servers => "172.30.32.85:9092,172.30.32.85:9093,172.30.32.85:9094"
    topics => ["tetragon.security.lsm"]
    group_id => "logstash-k8s-tetragon-security-lsm"
    auto_offset_reset => "latest"
    codec => json
    decorate_events => true
    # consumer_threads => 8
  }
  
  # Tetragon 事件 - 系统调用 kprobe
  kafka {
    bootstrap_servers => "172.30.32.85:9092,172.30.32.85:9093,172.30.32.85:9094"
    topics => ["tetragon.syscall.kprobe"]
    group_id => "logstash-k8s-tetragon-syscall-kprobe"
    auto_offset_reset => "latest"
    codec => json
    decorate_events => true
    # consumer_threads => 8
  }
  
  # Tetragon 事件 - 内核 tracepoint
  kafka {
    bootstrap_servers => "172.30.32.85:9092,172.30.32.85:9093,172.30.32.85:9094"
    topics => ["tetragon.kernel.tracepoint"]
    group_id => "logstash-k8s-tetragon-kernel-tracepoint"
    auto_offset_reset => "latest"
    codec => json
    decorate_events => true
    # consumer_threads => 8
  }
  
  # Tetragon 事件 - 未知类型
  kafka {
    bootstrap_servers => "172.30.32.85:9092,172.30.32.85:9093,172.30.32.85:9094"
    topics => ["tetragon.unknown"]
    group_id => "logstash-k8s-tetragon-unknown"
    auto_offset_reset => "latest"
    codec => json
    decorate_events => true
    # consumer_threads => 8
  }
  
  # Tetragon 事件 - 死信队列
  kafka {
    bootstrap_servers => "172.30.32.85:9092,172.30.32.85:9093,172.30.32.85:9094"
    topics => ["tetragon.dlq"]
    group_id => "logstash-k8s-tetragon-dlq"
    auto_offset_reset => "latest"
    codec => json
    decorate_events => true
    # consumer_threads => 8
  }
}

filter {
  # 处理时间戳
  if [timestamp] {
    date {
      match => ["timestamp", "ISO8601", "yyyy-MM-dd'T'HH:mm:ss.SSSZ", "yyyy-MM-dd'T'HH:mm:ssZ"]
      target => "@timestamp"
    }
  } else if [ts] {
    date {
      match => ["ts", "ISO8601"]
      target => "@timestamp"
    }
  }
  
  if ![timestamp] and ![ts] {
    ruby {
      code => "event.set('@timestamp', Time.now)"
    }
  }
  
  # 过滤掉不应该被记录的事件
  # 根据 Tetragon 规则，__sk_free 事件应该被 NoPost 过滤，但如果有事件漏过来，在这里过滤
  # 这样可以避免产生大量无用的日志
  if [extra] and [extra][function_name] == "__sk_free" {
    drop {}
  }
  
  # 从 Raw 字段提取完整的原始事件信息（包含所有 Tetragon 原始数据）
  # Raw 字段包含完整的 Tetragon 事件 JSON，包括所有网络连接信息、Pod 信息等
  ruby {
    code => "
      begin
        raw = event.get('raw')
        if raw.is_a?(Hash)
          # 提取 process_kprobe 事件中的完整信息
          if raw['process_kprobe']
            kprobe = raw['process_kprobe']
            
            # 提取进程信息（如果规范化字段中没有）
            if kprobe['process']
              proc = kprobe['process']
              # 提取 Pod 信息（包含完整的 Pod 对象）
              if proc['pod']
                pod = proc['pod']
                event.set('raw.pod.namespace', pod['namespace']) if pod['namespace']
                event.set('raw.pod.name', pod['name']) if pod['name']
                event.set('raw.pod.workload', pod['workload']) if pod['workload']
                if pod['container']
                  container = pod['container']
                  event.set('raw.pod.container.id', container['id']) if container['id']
                  event.set('raw.pod.container.name', container['name']) if container['name']
                  event.set('raw.pod.container.image', container['image']) if container['image']
                end
                if pod['pod_labels']
                  event.set('raw.pod.labels', pod['pod_labels'])
                end
              end
              
              # 提取网络连接参数（从 args 中提取 sock_arg）
              if kprobe['args']
                kprobe['args'].each do |arg|
                  if arg['sock_arg']
                    sock = arg['sock_arg']
                    event.set('raw.network.source_ip', sock['saddr']) if sock['saddr']
                    event.set('raw.network.source_port', sock['sport']) if sock['sport']
                    event.set('raw.network.destination_ip', sock['daddr']) if sock['daddr']
                    event.set('raw.network.destination_port', sock['dport']) if sock['dport']
                    event.set('raw.network.protocol', sock['protocol']) if sock['protocol']
                    event.set('raw.network.family', sock['family']) if sock['family']
                    event.set('raw.network.type', sock['type']) if sock['type']
                    event.set('raw.network.state', sock['state']) if sock['state']
                  end
                end
              end
            end
          end
          
          # 提取 process_exec 事件中的完整信息
          if raw['process_exec'] && raw['process_exec']['process']
            proc = raw['process_exec']['process']
            if proc['pod']
              pod = proc['pod']
              event.set('raw.pod.namespace', pod['namespace']) if pod['namespace']
              event.set('raw.pod.name', pod['name']) if pod['name']
            end
          end
          
          # 提取 process_tracepoint 事件中的完整信息
          if raw['process_tracepoint'] && raw['process_tracepoint']['process']
            proc = raw['process_tracepoint']['process']
            if proc['pod']
              pod = proc['pod']
              event.set('raw.pod.namespace', pod['namespace']) if pod['namespace']
              event.set('raw.pod.name', pod['name']) if pod['name']
            end
          end
        end
      rescue => e
        event.tag('_raw_extraction_error')
      end
    "
  }
  
  # 提取嵌套的 process 字段到顶层（使用点号分隔的字段名，便于 Elasticsearch 查询）
  # Tetragon Kafka Adapter 输出的格式：{"process": {"pid": 1234, "binary": "/bin/sh", ...}}
  # 使用 ruby 代码安全地提取嵌套字段，确保类型正确
  ruby {
    code => "
      begin
        process = event.get('process')
        if process.is_a?(Hash)
          # 安全地提取 PID，确保是有效的整数
          if process['pid']
            pid_val = process['pid']
            if pid_val.is_a?(Numeric)
              event.set('process.pid', pid_val.to_i)
            elsif pid_val.is_a?(String) && pid_val.match(/^\d+$/)
              pid_int = pid_val.to_i
              # 验证 PID 是否在合理范围内（Linux PID 最大通常是 4194304，但实际系统通常更小）
              if pid_int > 0 && pid_int < 10000000
                event.set('process.pid', pid_int)
              end
            end
          end
          
          # 提取其他 process 字段
          event.set('process.ppid', process['ppid'].to_i) if process['ppid'] && (process['ppid'].is_a?(Numeric) || (process['ppid'].is_a?(String) && process['ppid'].match(/^\d+$/)))
          event.set('process.uid', process['uid'].to_i) if process['uid'] && (process['uid'].is_a?(Numeric) || (process['uid'].is_a?(String) && process['uid'].match(/^\d+$/)))
          event.set('process.gid', process['gid'].to_i) if process['gid'] && (process['gid'].is_a?(Numeric) || (process['gid'].is_a?(String) && process['gid'].match(/^\d+$/)))
          event.set('process.binary', process['binary']) if process['binary']
          event.set('process.args', process['args']) if process['args']
          event.set('process.cwd', process['cwd']) if process['cwd']
        end
      rescue => e
        # 如果提取失败，记录错误但不中断处理
        event.tag('_process_extraction_error')
      end
    "
  }
  
  # 提取嵌套的 k8s 字段到顶层（使用点号分隔）
  # 优先从规范化字段提取，如果没有则从 Raw 字段提取
  ruby {
    code => "
      begin
        # 先尝试从规范化字段提取
        k8s = event.get('k8s')
        if k8s.is_a?(Hash)
          # 提取 namespace
          if k8s['namespace']
            event.set('k8s.namespace', k8s['namespace'])
          end
          # 提取 pod 名称
          if k8s['pod']
            event.set('k8s.pod', k8s['pod'])
          end
          # 提取 container 名称
          if k8s['container']
            event.set('k8s.container', k8s['container'])
          end
          # 标记这是容器进程
          event.set('is_container', true)
        else
          # 如果规范化字段没有，尝试从 Raw 字段提取
          if event.get('raw.pod.namespace')
            event.set('k8s.namespace', event.get('raw.pod.namespace'))
            event.set('k8s.pod', event.get('raw.pod.name'))
            event.set('k8s.container', event.get('raw.pod.container.name'))
            event.set('is_container', true)
          else
            # 如果没有 k8s 信息，标记为 host 进程
            event.set('is_container', false)
            event.set('k8s.namespace', 'host')
            event.set('k8s.pod', 'host')
          end
        end
      rescue => e
        # 如果提取失败，标记为未知
        event.set('is_container', false)
        event.tag('_k8s_extraction_error')
      end
    "
  }
  
  # 提取 extra 字段中的 function_name（用于 kprobe 事件）
  if [extra] and [extra][function_name] {
    mutate {
      add_field => { "extra.function_name" => "%{[extra][function_name]}" }
    }
  }
  
  # 提取网络连接信息（优先从规范化字段，如果没有则从 Raw 字段提取）
  ruby {
    code => "
      begin
        # 先尝试从规范化字段提取
        network = event.get('network')
        if network.is_a?(Hash)
          event.set('network.source_ip', network['source_ip']) if network['source_ip']
          event.set('network.source_port', network['source_port']) if network['source_port']
          event.set('network.destination_ip', network['destination_ip']) if network['destination_ip']
          event.set('network.destination_port', network['destination_port']) if network['destination_port']
          event.set('network.protocol', network['protocol']) if network['protocol']
          event.set('network.family', network['family']) if network['family']
        end
        
        # 如果规范化字段没有，从 Raw 字段提取（作为备用）
        if !event.get('network.source_ip') && event.get('raw.network.source_ip')
          event.set('network.source_ip', event.get('raw.network.source_ip'))
          event.set('network.source_port', event.get('raw.network.source_port'))
          event.set('network.destination_ip', event.get('raw.network.destination_ip'))
          event.set('network.destination_port', event.get('raw.network.destination_port'))
          event.set('network.protocol', event.get('raw.network.protocol'))
          event.set('network.family', event.get('raw.network.family'))
        end
      rescue => e
        event.tag('_network_extraction_error')
      end
    "
  }
  
  # 提取 labels 字段
  if [labels] {
    if [labels][event_subtype] {
      mutate {
        add_field => { "labels.event_subtype" => "%{[labels][event_subtype]}" }
      }
    }
    if [labels][source] {
      mutate {
        add_field => { "labels.source" => "%{[labels][source]}" }
      }
    }
  }
  
  # 标准化日志级别字段（如果是应用日志）
  if [level] {
    mutate {
      uppercase => ["level"]
    }
  }
  
  # 处理消息字段：将 msg 重命名为 message（如果需要）
  if [msg] and ![message] {
    mutate {
      rename => { "msg" => "message" }
    }
  }
  
  # 移除不需要的字段
  mutate {
    remove_field => ["event"]
  }
  
  # 生成索引日期（UTC+8，格式：YYYY.MM.dd）
  ruby {
    code => "event.set('index_date', event.get('@timestamp').time.localtime('+08:00').strftime('%Y.%m.%d'))"
  }
  
  # 根据 Kafka topic 设置事件类型和服务标识（统一索引名称）
  if [@metadata][kafka][topic] == "tetragon.process.exec" {
    mutate {
      add_field => { "service" => "tetragon" }
      add_field => { "log_type" => "tetragon-event" }
      add_field => { "event_type" => "process_exec" }
    }
  } else if [@metadata][kafka][topic] == "tetragon.process.exit" {
    mutate {
      add_field => { "service" => "tetragon" }
      add_field => { "log_type" => "tetragon-event" }
      add_field => { "event_type" => "process_exit" }
    }
  } else if [@metadata][kafka][topic] == "tetragon.security.lsm" {
    mutate {
      add_field => { "service" => "tetragon" }
      add_field => { "log_type" => "tetragon-event" }
      add_field => { "event_type" => "security_lsm" }
    }
  } else if [@metadata][kafka][topic] == "tetragon.syscall.kprobe" {
    mutate {
      add_field => { "service" => "tetragon" }
      add_field => { "log_type" => "tetragon-event" }
      add_field => { "event_type" => "syscall_kprobe" }
    }
  } else if [@metadata][kafka][topic] == "tetragon.kernel.tracepoint" {
    mutate {
      add_field => { "service" => "tetragon" }
      add_field => { "log_type" => "tetragon-event" }
      add_field => { "event_type" => "kernel_tracepoint" }
    }
  } else if [@metadata][kafka][topic] == "tetragon.unknown" {
    mutate {
      add_field => { "service" => "tetragon" }
      add_field => { "log_type" => "tetragon-event" }
      add_field => { "event_type" => "unknown" }
    }
  } else if [@metadata][kafka][topic] == "tetragon.dlq" {
    mutate {
      add_field => { "service" => "tetragon" }
      add_field => { "log_type" => "tetragon-event" }
      add_field => { "event_type" => "dlq" }
    }
  }
}

output {
  elasticsearch {
    user => "elastic"
    password => "c7jAJ-cA6Lw1MGeByfG9"
    hosts => ["http://172.30.32.71:9200", "http://172.30.32.72:9200", "http://172.30.32.73:9200", "http://172.30.32.74:9200", "http://172.30.32.75:9200"]
    # 统一索引名称：所有事件类型写入同一个索引
    index => "logstash-k8s-tetragon-policy-%{index_date}"
  }
  
  # 调试输出（可选，生产环境建议注释掉）
  # stdout {
  #   codec => json
  # }
}
